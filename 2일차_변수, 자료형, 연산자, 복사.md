<details markdown="1">
  <summary>리뷰</summary>
  <div>
    평소에 C++이랑 Java 위주로 써와서 파이썬 기본 문법을 잘 숙지해야겠다는 마음가짐으로 들었다. 그래도 나름 문법 공부를 가끔씩 해와서 그런가 오히려 정리되는 느낌으로 들었고, 다른 언어랑 비교까지 할 수 있었다. 1학년 땐 어려웠던 컨테이너 자료형도 이제는 쉽게 느껴졌다!😎<br>
    기본 문법을 아는 것과 활용하는 건 다르기에 종종 기본 자료구조 문제를 파이썬으로 풀어봐야겠다. <br><br>
    목 상태가 안 좋아서 일찍 자려고 했으나 복습도 하고, 수업 내용을 문서화하는 양식도 정하려고 1월 1일에 이러고 있는 중🔥
  </div>
</details>

# Future Action

- [ ]  문자열 관련 함수 공식 문서 살펴보기
- [ ]  자료구조 문제 파이썬으로 풀어보기
- [ ]  복습!!

---

# 변수

### 변수 명명 규칙

- snake_case
- 영문 대/소문자, 숫자, 한글 사용 가능
    - 숫자는 사용 가능하지만 맨 앞에는 올 수 없음
- 특수문자는 거의 `_`만 사용
- 권장하는 변수 이름 짓는 방법
    - 시작은 소문자
    - 예약어를 변수명으로 사용하는 것은 자제
        - 사용은 가능하지만 사용한 뒤로는 예약어로서의 기능을 못함

### 값 교환

python에서는 다른 언어와는 달리 바로 값을 swap해줄 수 있다. 

```python
a, b = b, a
a, b
```

# 스칼라 자료형

> 한 변수에 숫자나 참/거짓 등 하나의 값을 담는 자료형들
> 

### 1) 정수(int)

- 기본적으로 4바이트를 할당
- 4바이트를 넘어가면 **임의 정밀도**(**arbitrary precision)**를 이용해 필요한 메모리만큼 할당해서 처리해줌 → 거의 모든 숫자를 표현할 수 있음
- 실제 정수형 변수를 선언하면 작은 숫자라도 기본 4바이트에 메모리 주소 등과 같은 메타데이터가 더해져 4바이트보다 큼

### 2) 실수 또는 부동소수점(float)

- 소수점 위치가 고정되지 않고 바뀌는 부동소수점 방식이 사용됨
- 오차가 발생할 수 있다는 단점이 있음

>[!NOTE]
><ins>**decimal 모듈**<ins>
>
>정확한 십진수 기반의 연산이 필요한 경우 파이썬에서 제공하는 decimal 내장 모듈을 사용하면 된다.
>```python
>value = 0.1 + 0.2
>print(value) # 출력 : 0.30000000000000004
>```
>```python
>from decimal import Decimal
>
>value = Decimal('0.1') + Decimal('0.2')
>print(value) # 출력 : 0.3
>```
>
>특징
>
>1. Decimal은 소수점 아래 정밀도 지정 가능
>    
>    ```python
>    from decimal import Decimal, getcontext
>
>    getcontext().prec = 6 # 소수점 아래 6자리까지 정밀도 설정
>    print(Decimal(1) / Decimal(7))  # 출력: 0.142857
>    ```
>    
>2. Decimal 사용시 항상 문자열 혹은 정수를 통해 생성해야 함
>    
>    float형을 통해 생성하면 부동 소수점 문제가 그대로 발생한다.
>    
>3. 상대적으로 연산 속도가 느림
>4. Decimal과 int는 서로 연산 가능 → 결과는 Decimal 
>5. Decimal과 float는 서로 계산 불가 


### 3) 불리언(bool)

파이썬에서의 참, 거짓은 True(1), False(0)이다. 
대문자로 시작한다는 점을 유의하자.

### 4) 문자열(str)

- 문자열을 표현하는 방법
    - `' '`
    - `" "`
    - `''' '''`
    - `""" """`
- 문자열 이스케이프
    - ‘나 \, 엔터 등 파이썬에서 이미 약속된 규칙으로 사용되는 기호를 문자열에서 표현할 때는 역슬래시(`\`)를 그 문자 앞에 사용한다.
    - 문자열을 통으로 캡처해서 출력하는 방식도 있다.
        
        ```python
        print(r"C:\ITStudy\01_ptyhonBasic") # 문자를 통으로 출력
        ```
        

### 5) 값없음(None)

# 컨테이너 자료형

> 여러개의 자료를 원소로 묶어 하나의 변수에 담는 형태의 자료형
> 

## 시퀀스 타입

### 1) 리스트(list)

- 꺽은 괄호 [] 로 묶어서 배열 형태로 만든 자료형
- 순서가 있어서 인덱스로 호출 가능
- 원소 내용 변경 가능
- Linked List처럼 저장됨 (참조 자료형)

### 2) 튜플(tuple)

- 둥근 괄호 ()로 묶어서 사용
- 순서가 있어서 인덱스로 호출 가능
- 변수를 한 번 생성하면 원소의 내용을 변경할 수 없음
- 튜플끼리 더하기 연산을 하면 새로운 튜플을 만들어서 메모리가 반환됨
- 문자열(String)도 튜플의 속성을 가짐

### 3) 레인지(range)

- 정수 수열을 만들어 냄 - `range(시작점, 끝점+1, 건너뛸 step)`
- 원소의 내용을 변경할 수 없음
- 메모리 효율성을 위해 **지연 평가(lazy evaluation) 방식**을 사용하며, 실제로 해당 값이 필요한 시점에만 메모리에 로드되어 처리됨

```python
li = [1, 2, 3] # 리스트 선언
tu = (1, 2, 3) # 튜플 선언
ra = range(1, 4) # range 선언 
```

### 4) 연산자

- 공통 연산자
    
    : 가변형 타입과 불가변형 타입 모두에게 동일하게 사용할 수 있는 연산자
    ⇒ `index`, `count`, `+`, `*`, `in` 등
    
- 가변 연산자
    
     : 가변형 타입에서만 사용 가능한 연산자(string, 튜플에서는 사용 불가)
    
    - `append` : 하나만 추가
        
        ```python
        li = [1, 2, 3]
        li.append([4, 5, 6])
        li # 출력 : [1, 2, 3, [4, 5, 6]]
        ```
        
    - `extend` : 여러개 한번에 추가
        
        ```python
        li = [1, 2, 3]
        li.extend([4, 5, 6]) # 반드시 추가할 값들을 []로 묶어줘야 함
        li # 출력 : [1, 2, 3, 4, 5, 6]
        ```
        
    - `insert` : 중간에 원하는 위치에 원소 삽입
        
        ```python
        li = [1, 2, 3]
        li.insert(1, ['가', '나', 6] # 1번째 위치에 ['가', '나', 6] 값을 추가
        ```
        
    - `pop` : 지정한 인덱스에 위치한 원소를 뺌 (기본은 맨 마지막 원소)
    - `remove` : 값과 일치하는 원소를 뺌
    - `sort` : 원소 정렬 (자료형이 다른 경우 `TypeError` 발생)
    - `reverse` : 순서 뒤집기
    
    <aside>
    💡
    
    sort()와 reverse()는 메모리를 아끼기 위해 원본 자체를 변경하기 때문에 화면에 return하지 않는다. 
    
    </aside>
    
- 인덱싱
    
    : 0부터 순서대로 1씩 증가하면서 인덱스가 생성됨
    
- 슬라이스
    
    : 원하는 범위를 잘라서 가져옴
    
    - `arr[ 시작인덱스 : 끝인덱스+1 ]`
    - `arr[ 시작인덱스 : 끝인덱스+1: step` ]

## 매핑형 타입

### 1) 딕셔너리(Dict)

- HashTable 방식으로 구현되어 있으며, 중괄호 {key:value}로 선언
- 데이터 저장과 읽기 속도가 빠르고, 키 중복 여부를 확인하기 쉬움
- 일반적으로 다른 자료구조보다 저장 공간이 더 필요
- 충돌을 해결하기 위한 별도 자료구조 또는 함수가 필요
- 캐시 구현할 때 주로 사용됨
- dict의 메서드는 대부분 key 중심으로 동작
- `keys()`, `values()`, `items()` 함수는 각각 `dict_keys`, `dict_values` , `dict_items` 자료형을 결과값으로 return

## 집합형 타입

### 1) 집합(Set)

- key로 관리하는 Hash 자료구조이며, 중괄호 {}로 선언
- 순서가 없고, 중복 불가
- `&`, `-`, `|` 으로 교집합, 차집합, 합집합 연산 가능

# 연산자

>[!NOTE]
>**TIP 1** - 코드가 길어지는 경우 백슬래쉬(\)를 이용해 줄바꿈을 하자.
>
>**TIP 2** - 연산자로 길어지는 경우 연산자 이전에 줄바꿈하는 것이 가독성이 좋음!

### 완전 항등 연산자

`a === b` 와 같이 등호 3개를 사용한 연산자를 완전 항등 연산자라고 부른다. 완전 항등 연산자는 메모리 주소, 자료형, 값을 모두 비교했을 때 동일한 경우에만 True를 반환한다.  

### 연산자 우선순위

`(` `)` > `**` > `-(negative)` > `*`, `/`, `//`, `%` > `+`, `-`

### 논리 연산 우선순위

`not` > `and` > `or`

> **or의 우선순위가 가장 낮은 이유**
앞에 나온 조건만 참이면 바로 참을 반환하고 뒤에 나오는 조건문을 검사하지 않는 단락평가(Circuit Evaluation) 방식 때문이다.
> 

### 형변환

- `str()`, `int()`, `float()`, `bool()`
- 파이썬은 자료형을 명시하지 않아도 인터프리터가 알아서 자료형을 지정
- 문자열을 정수나 실수로 변환할 때 주의사항
    - 문자열 내에 문자들이 전부 10진수 정수 형태여야 함
    - 0으로 시작하는 건 정수 타입으로 형변환 불가

# 복사

### 얕은 복사(Shallow Copy)

- 파이썬의 기본 복사 방식
- 공간 효율성, 메모리 효율성을 위해 동일한 메모리 주소를 가리키는 복사

>[!NOTE]
>
> <ins>**슬라이싱하면 깊은 복사 같은데 왜 얕은 복사일까?**<ins>
>
>슬라이싱으로 일부만 가져오면 새로운 메모리를 할당하지만, **차원을 하나 더 깊게 들어가면 여전히 같은 메모리 주소를 가리키고 있는다.** 
>
>```python
>arr = ['Hello', 'Bye', 'Hi', ['Goodnight', 'Goodmorning', 'Goodafternoon']]
>
>arr_slice = arr[2:5]
>arr_slice[0] = "Thx"
>print(arr_slice) 
># 출력 : ['Thx', ['Goodnight', 'Goodmorning', 'Goodafternoon']]
>
>arr_slice[-1][-1] = "좋은날"
>print(arr_slice, arr) 
># 출력 : ['Thx', ['Goodnight', 'Goodmorning', '좋은날']] 
>#       ['Hello', 'Bye', 'Hi', ['Goodnight', 'Goodmorning', '좋은날']]
>```
>
>슬라이스로 `arr_slice`라는 새로운 리스트가 만들어져서 0번째 원소를 “Thk”로 바꿔도 원본은 훼손되지 않는다.
>
>하지만 더 깊은 차원인 1번째 원소의 마지막 원소를 바꾸면 `arr_slice`의 변화가 `arr`에도 적용된다. 

</aside>

### 깊은 복사(Deep Copy)

- 새로운 메모리 공간에 복사하여 원본이 훼손되는 것을 방지하는 복사 방식
- `copy`라는 모듈의 `deepcopy`함수를 사용하여 깊은 복사를 수행
